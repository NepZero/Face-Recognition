# 人脸识别系统业务流程

## 系统角色与权限

### 角色定义
- **学生 (student)**: 注册时必须选择班级，可以查看自己班级的签到任务并进行签到
- **老师 (teacher)**: 预置账号，可以发布签到任务、查看签到统计

### 权限矩阵
| 功能 | 学生 | 老师 |
|------|------|------|
| 注册账号 | ✅ | ❌ |
| 登录系统 | ✅ | ✅ |
| 人脸注册 | ✅ | ✅ |
| 人脸识别签到 | ✅ | ❌ |
| 查看班级列表 | ✅ | ✅ |
| 发布签到任务 | ❌ | ✅ |
| 查看签到任务 | ✅ (仅自己班级) | ✅ (自己发布的) |
| 查看签到统计 | ❌ | ✅ |

## 用户管理流程

### 1. 学生注册流程
```
学生填写注册信息 → 选择班级 → 前端验证 → 发送注册请求 → 后端验证 → 密码加密 → 存储数据库 → 返回注册结果
```

**详细步骤**：
1. **前端收集**：学生输入账号、密码、姓名
2. **班级选择**：从班级列表中选择班级
3. **前端验证**：检查必填字段、格式验证、班级选择
4. **发送请求**：POST /api/register
5. **后端验证**：检查账号是否已存在、班级是否存在
6. **密码加密**：使用bcrypt加密密码
7. **数据库存储**：插入学生记录（角色固定为student）
8. **返回结果**：返回注册成功/失败信息

**业务规则**：
- 只支持学生注册，角色固定为student
- 账号必须唯一
- 密码长度至少6位
- 姓名可选填写
- 必须选择班级
- 老师账号已预置，无需注册
- 注册成功后用户状态为未注册人脸

### 2. 老师账号管理
```
系统预置老师账号 → 数据库存储 → 老师直接登录使用
```

**预置数据**：
- teacher001 (张老师) - 密码: 123456
- teacher002 (李老师) - 密码: 123456
- teacher003 (王老师) - 密码: 123456
- teacher004 (赵老师) - 密码: 123456
- teacher005 (刘老师) - 密码: 123456

**业务规则**：
- 老师账号由系统预置
- 老师无需注册，直接使用预置账号登录
- 老师角色固定为teacher

### 3. 用户登录流程（JWT）
```
用户输入账号密码 → 前端验证 → 发送登录请求 → 后端验证 → 密码比对 → 签发JWT → 返回accessToken与用户信息
```

**详细步骤**：
1. **前端收集**：用户输入账号和密码
2. **发送请求**：POST /api/login
3. **数据库查询**：根据账号查找用户
4. **密码验证**：使用bcrypt比对密码
5. **签发令牌**：生成JWT（包含用户ID、角色、班级等）
6. **返回信息**：返回accessToken、有效期与用户基本信息

**业务规则**：
- 账号和密码必须匹配
- 登录成功后返回JWT，不再创建session
- 返回用户ID、账号、姓名、角色、班级ID、人脸注册状态
- 根据角色返回不同的功能权限

### 4. 用户登出流程（无状态）
```
用户点击登出 → 前端删除本地token（可选调用后端登出接口） → 返回登出成功
```

**详细步骤**：
1. **发送请求**：POST /api/logout
2. **删除令牌**：前端移除本地存储的accessToken
3. **（可选）调用后端**：POST /api/logout 固定返回成功
4. **返回确认**：前端状态清理完成

## 班级管理流程

### 1. 班级数据管理
```
系统预置班级数据 → 数据库存储 → 前端获取班级列表 → 学生注册时选择
```

**预置班级数据**：
- 计算机科学与技术2023级1班 (CS2023-1)
- 计算机科学与技术2023级2班 (CS2023-2)
- 软件工程2023级1班 (SE2023-1)
- 软件工程2023级2班 (SE2023-2)
- 人工智能2023级1班 (AI2023-1)

### 2. 获取班级列表流程
```
前端请求班级列表 → 后端查询数据库 → 返回班级信息 → 前端显示供选择
```

**详细步骤**：
1. **前端请求**：GET /api/classes
2. **数据库查询**：查询所有班级信息
3. **数据返回**：返回班级ID、名称、代码
4. **前端显示**：供学生注册时选择

**业务规则**：
- 班级数据由系统预置
- 学生注册时必须选择班级
- 老师可以查看所有班级信息

## 签到任务管理流程

### 1. 老师发布签到任务流程（含实时推送）
```
老师登录 →（班级从JWT中classId确定/或由系统上下文确定）→ 填写持续时长 → 发送请求（带Authorization头） → 后端验证 → 创建任务（开始/结束时间由后端计算） → Socket.IO实时推送 → 返回结果
```

**详细步骤**：
1. **老师登录**：验证老师身份（JWT）
2. **填写信息**：输入任务名称、选择班级、设置开始和结束时间
3. **前端验证**：检查必填字段、时间逻辑
4. **发送请求**：POST /api/attendance-task（Header: Authorization: Bearer <token>）
5. **后端验证**：验证老师权限、班级存在性、老师班级权限、时间逻辑
6. **创建任务**：插入签到任务记录到数据库
7. **实时推送**：通过 Socket.IO 推送给对应班级的所有在线学生（房间：`class-{classId}`）
8. **返回结果**：返回任务创建成功/失败信息

**实时推送机制**：
- 老师发布任务成功后，系统立即通过 Socket.IO 向目标班级的房间推送新任务
- 所有已连接且在该班级房间的在线学生立即收到 `new-task` 事件
- 学生无需轮询 API，即可实时看到新发布的签到任务
- 推送内容包括任务ID、名称、开始/结束时间、班级信息等

**业务规则**：
- 只有老师可以发布签到任务
- 老师只能为自己所在的班级发布签到任务
- 任务名称最多100字符
- 开始时间必须早于结束时间
- 结束时间必须晚于当前时间
- 目标班级必须存在且老师必须属于该班级
- 任务发布成功后立即通过 Socket.IO 实时推送

### 2. 查看签到任务流程（支持实时推送和API查询）

**方式一：实时推送（推荐）**
```
学生登录 → 连接Socket.IO → 加入班级房间 → 监听new-task事件 → 实时接收任务推送 → 前端自动更新
```

**方式二：API查询**
```
用户登录 → 根据角色查询 → 返回任务列表 → 前端显示
```

**详细步骤**：

**实时推送流程**：
1. **学生登录**：验证学生身份（JWT）
2. **Socket连接**：前端连接 Socket.IO 服务器（握手传递 token）
3. **身份验证**：Socket.IO 验证 token，获取用户信息和班级ID
4. **加入房间**：学生自动加入对应班级的房间（`class-{classId}`）
5. **监听事件**：前端监听 `new-task` 事件
6. **接收推送**：当老师发布新任务时，自动收到推送消息
7. **更新界面**：前端自动更新任务列表，无需刷新页面

**API查询流程**：
1. **用户登录**：验证用户身份和角色（JWT）
2. **角色判断**：
   - 学生：查询自己班级的任务
   - 老师：查询自己发布的任务
3. **数据查询**：GET /api/attendance-tasks（Header: Authorization）或通过Socket（携带token）发送 `get-tasks`
4. **结果返回**：返回任务列表和详细信息
5. **前端显示**：根据角色显示不同的任务列表

**业务规则**：
- 学生只能查看自己班级的任务
- 老师只能查看自己发布的任务
- 支持按状态和班级筛选
- 返回任务详细信息包括班级名称、老师姓名
- **推荐使用 Socket.IO 实时推送**，避免频繁轮询 API
- Socket 连接断开时，可降级使用 REST API 查询

### 3. 签到统计查看流程
```
老师登录 → 选择任务 → 发送统计请求 → 后端计算统计 → 返回统计数据
```

**详细步骤**：
1. **老师登录**：验证老师身份（JWT）
2. **选择任务**：选择要查看统计的签到任务
3. **发送请求**：GET /api/attendance-stats?taskId=xxx（Header: Authorization）
4. **数据统计**：计算总学生数、已签到数、签到率
5. **详情查询**：获取签到学生详情
6. **结果返回**：返回完整的统计数据

**业务规则**：
- 只有老师可以查看签到统计
- 统计包括总学生数、已签到数、签到率
- 提供详细的签到学生信息
- 按签到时间排序

## 人脸识别流程

### 1. 人脸注册流程（自动保存样本并重训练，支持首次注册冷启动）

**首次注册流程**（用户 `faceRegistered=0`）：
```
用户上传人脸图片 → 前端验证 → 发送注册请求 → 后端接收图片 → 跳过识别校验 → 直接复制样本到训练集 → 触发训练脚本生成/更新模型 → 更新用户状态 → 返回注册结果
```

**非首次注册流程**（用户 `faceRegistered=1`）：
```
用户上传人脸图片 → 前端验证 → 发送注册请求 → 后端接收图片 → 调用Python识别校验 → 匹配成功：复制样本到训练集 → 触发训练脚本生成/更新模型 → 更新用户状态 → 返回注册结果
```

**详细步骤**：

**首次注册场景**：
1. **图片上传**：用户选择并上传人脸图片
2. **前端验证**：检查文件类型、大小
3. **发送请求**：POST /api/face-register (multipart/form-data)
4. **后端处理**：使用multer接收图片文件
5. **查询用户状态**：检查 `user.faceRegistered`，若为 0 则进入冷启动流程
6. **跳过识别校验**：首次注册不需要识别匹配（模型尚未包含该用户）
7. **样本入库**：直接复制图片到 `opencv/face_get/Facedata/<name>.<userId>.<timestamp>.<ext>`
8. **训练更新**：调用 `opencv/face_get/trainner.py` 生成/更新 `face_trainer/trainer.yml`
9. **状态更新**：后端更新用户 `faceRegistered=1`
10. **返回结果**：`{ success:true, message:'人脸注册成功（首次注册）', data:{ savedToDataset:true, retrained:true, coldStart:true } }`

**非首次注册场景**：
1. **图片上传**：用户选择并上传人脸图片
2. **前端验证**：检查文件类型、大小
3. **发送请求**：POST /api/face-register (multipart/form-data)
4. **后端处理**：使用multer接收图片文件
5. **查询用户状态**：检查 `user.faceRegistered`，若为 1 则进入校验流程
6. **Python识别校验**：后端以子进程调用 `opencv/face_get/rec.py <图片路径>`，解析 stdout JSON
7. **匹配验证**：只有当识别结果中的 `userId` 与提交的 `userId` 一致时，才继续流程
8. **样本入库**：匹配成功后复制图片到 `opencv/face_get/Facedata/<name>.<userId>.<timestamp>.<ext>`
9. **训练更新**：调用 `opencv/face_get/trainner.py` 生成/更新 `face_trainer/trainer.yml`
10. **状态更新**：确保 `user.faceRegistered=1`
11. **返回结果**：`{ success:true, data:{ savedToDataset:true, retrained:true, coldStart:false } }`

#### 1.1 非首次注册的识别校验机制详解

**校验目的**：确保用户上传的人脸图片确实是该用户本人，防止数据污染（误将他人照片加入训练集）。

**校验原理**：不是直接比对已有照片和上传照片，而是通过训练好的机器学习模型进行识别，然后比对识别结果。

**完整校验流程**：

```
第一步：训练阶段（已有照片 → 模型）
已有训练照片（Facedata/name.id.index.jpg）
  ↓
训练脚本 trainner.py
  ↓
提取人脸特征（LBPH算法）
  ↓
训练模型
  ↓
生成 trainer.yml（包含所有人脸特征数据）

第二步：识别校验阶段（新照片 → 模型识别 → 比对结果）
用户上传的新照片
  ↓
rec.py 加载 trainer.yml（训练好的模型）
  ↓
使用模型识别新照片中的人脸
  ↓
模型输出识别结果：{recognized: true, userId: 6}
  ↓
后端比对：识别出的 userId === 用户提交的 userId？
  ↓
✅ 匹配 → 保存新照片并重训练
❌ 不匹配 → 返回错误，拒绝保存
```

**校验逻辑**（后端代码 `app.js` 第 463 行）：

```javascript
// 用户提交：userId = 6
// 模型识别结果：{recognized: true, userId: 6}

const isMatchUser = pyResult.recognized && 
                    String(pyResult.userId) === String(userId);

// 校验条件：
// 1. recognized === true（成功识别到已知人脸）
// 2. 识别出的 userId === 提交的 userId（身份一致）
```

**校验失败的情况**：

| 失败场景 | 原因 | 识别结果 | 校验结果 |
| --- | --- | --- | --- |
| 图片中无人脸 | 上传了风景照、物品照等 | `{recognized: false}` | ❌ 失败 |
| 图片质量太差 | 模糊、光线不足、角度不对 | `{recognized: false}` 或置信度过高 | ❌ 失败 |
| 上传他人照片 | 用户A上传了用户B的照片 | `{recognized: true, userId: 7}`（提交的是6） | ❌ 失败 |
| 模型问题 | 模型文件损坏或训练不完整 | `{recognized: false}` | ❌ 失败 |

**实际校验示例**：

**✅ 成功场景**：
```
场景：用户张三（ID=6，已注册）要追加训练样本

1. 前端提交：userId = 6，上传张三本人照片
2. 后端识别：调用 rec.py，通过 trainer.yml 模型识别
   识别结果：{recognized: true, userId: 6}
3. 后端校验：6 === 6 → 校验通过 ✅
4. 保存样本：复制到 Facedata/zhang.6.timestamp.jpg
5. 重训练：更新 trainer.yml 模型
6. 返回成功
```

**❌ 失败场景1（上传他人照片）**：
```
场景：用户张三（ID=6）误上传了李四（ID=7）的照片

1. 前端提交：userId = 6，但上传了李四的照片
2. 后端识别：识别结果：{recognized: true, userId: 7}
3. 后端校验：7 !== 6 → 校验失败 ❌
4. 返回：400 "人脸注册失败：未识别到该用户的人脸"

结果：安全机制生效，阻止了数据污染 ✅
```

**❌ 失败场景2（图片质量差）**：
```
场景：用户上传了模糊照片

1. 前端提交：userId = 6，上传模糊照片
2. 后端识别：识别结果：{recognized: false}
3. 后端校验：recognized === false → 校验失败 ❌
4. 返回：400 "人脸注册失败：未识别到该用户的人脸"

原因：图片质量问题导致无法准确识别
```

**为什么用模型而不是直接比对照片**：

1. **效率更高**：模型文件（几MB）比大量原图（可能几百MB）小得多
2. **特征匹配**：模型提取的是人脸特征，而不是简单的像素级比对
3. **容错性强**：能处理光照、角度、表情、年龄等变化
4. **可扩展**：新增用户只需重新训练，不用遍历所有照片进行比对

**总结**：非首次注册的校验机制通过机器学习模型识别新上传照片中的人脸，然后比对模型识别出的用户ID与用户提交的用户ID是否一致。这确保了只有用户本人的照片才会被加入训练集，有效防止了数据污染，保证了模型训练的准确性和安全性。

**业务规则**：
- 图片必须是有效的图片格式
- 图片大小不超过20MB
- 训练数据与数据库 `user.id` 必须对齐（文件名中的 `id`）
- **首次注册（coldStart: true）**：跳过识别校验，直接入库并重训练，适合新用户首次录入人脸
- **非首次注册（coldStart: false）**：需要识别校验通过后才保存样本，防止误将他人照片加入训练集
- 每次注册成功后都会自动重训练，模型实时更新
- 注册成功后用户状态更新为已注册人脸

### 2. 人脸识别流程（含自动签到）
```
学生上传识别图片 → 选择签到任务 → 前端验证 → 发送识别请求 → 后端接收图片 → 调用Python识别脚本 → Python模型识别 → 返回识别结果 → 查询用户信息 → 验证签到任务 → 自动记录签到 → 返回识别结果和签到状态
```

**详细步骤**：
1. **图片上传**：学生上传待识别的人脸图片
2. **任务选择**：选择要签到的任务（可选）
3. **发送请求**：POST /api/face-recognition (包含taskId)
4. **后端处理**：接收并存储图片文件到 `back/public`
5. **Python识别调用**：后端以子进程调用 `opencv/face_get/rec.py <图片绝对路径>`
6. **Python模型识别**：通过训练好的 LBPH 模型进行人脸识别
7. **结果返回**：Python 脚本返回 JSON 识别结果到 stdout
8. **用户查询**：如果识别成功，根据识别出的 userId 查询用户详细信息
9. **任务验证**：如果提供了taskId，验证任务的有效性和时间范围
10. **自动签到**：验证通过后自动记录签到到数据库
11. **结果返回**：返回识别结果、用户信息和签到状态

#### 2.1 Python 识别逻辑详解（`rec.py`）

**调用流程**：

```
后端 app.js
  ↓
runPythonRecognition(图片绝对路径)
  ↓
子进程执行：py -3 rec.py <图片绝对路径>
  ↓
rec.py 处理
  ↓
stdout 输出 JSON
  ↓
后端解析 JSON
```

**详细代码逻辑**：

**阶段1：初始化与映射建立**（第 7-24 行）

```python
# 建立 ID→名字映射（从训练数据文件名提取）
FACE_DATA_DIR = os.path.join(os.path.dirname(__file__), 'Facedata')
id2name = {}
for fname in os.listdir(FACE_DATA_DIR):
    # 从文件名 gpt.6.1.jpg 提取 ID=6, name="gpt"
    id_part = fname.split(".")[1]
    name_part = fname.split(".")[0]
    id2name[int(id_part)] = name_part  # {6: "gpt"}
```

**作用**：建立用户ID与名字的映射关系，用于返回用户名。

**阶段2：图片读取**（第 31-37 行）

```python
img_path = sys.argv[1]  # 从命令行参数获取图片路径
img = cv2.imread(img_path)  # 读取图片

if img is None:
    # 图片读取失败，返回未识别
    print(json.dumps({"recognized": False, "message": "unknown"}))
```

**作用**：读取后端传入的图片文件。

**阶段3：模型加载**（第 39-43 行）

```python
# 加载 LBPH 人脸识别模型（训练好的）
recognizer = cv2.face.LBPHFaceRecognizer_create()
recognizer.read('face_trainer/trainer.yml')

# 加载 Haar Cascade 人脸检测器（用于检测人脸位置）
face_cascade = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')
```

**作用**：
- 加载已训练的 LBPH 模型（包含所有人脸特征）
- 加载 Haar Cascade 用于人脸位置检测

**阶段4：人脸检测**（第 45-49 行）

```python
# 转换为灰度图
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# 检测图片中的人脸位置
# 参数：scaleFactor=1.2, minNeighbors=5
faces = face_cascade.detectMultiScale(gray, 1.2, 5)

if len(faces) == 0:
    # 未检测到人脸，返回未识别
    print(json.dumps({"recognized": False, "message": "unknown"}))
```

**作用**：在图片中检测人脸区域。未检测到人脸则直接返回未识别。

**阶段5：人脸识别**（第 50-63 行）

```python
else:
    # 提取第一张人脸区域
    x, y, w, h = faces[0]
    face = gray[y:y+h, x:x+w]  # 裁剪出人脸区域
    
    # 使用 LBPH 模型进行识别
    # idnum: 识别出的用户ID
    # conf: 置信度（越小表示越相似，0表示完全匹配）
    idnum, conf = recognizer.predict(face)
    
    # 置信度阈值判断（conf < 100 认为识别成功）
    if conf < 100:
        name = id2name.get(idnum, f"id_{idnum}")
        result = {
            "recognized": True,
            "userId": int(idnum),
            "userName": name
        }
    else:
        result = {"recognized": False, "message": "unknown"}
    
    # 输出 JSON 结果到 stdout（后端从这里读取）
    print(json.dumps(result, ensure_ascii=False))
```

**作用**：
- 裁剪人脸区域
- 使用 LBPH 模型识别，得到用户ID和置信度
- 判断识别是否成功（置信度 < 100）
- 输出 JSON 结果到 stdout

**阶段6：退出**（第 65 行）

```python
sys.exit(0)  # 正常退出，确保只输出一次 JSON
```

**完整识别流程图**：

```
后端调用：runPythonRecognition("back/public/imagefile-xxx.jpg")
  ↓
执行命令：py -3 rec.py back/public/imagefile-xxx.jpg
  ↓
rec.py 执行：
  ├─ [1] 初始化：扫描 Facedata/ 建立 id→name 映射
  ├─ [2] 读取图片：cv2.imread(图片路径)
  ├─ [3] 加载模型：
  │     - recognizer.read("face_trainer/trainer.yml")（LBPH模型）
  │     - CascadeClassifier("haarcascade_frontalface_default.xml")（检测器）
  ├─ [4] 转换为灰度图：cv2.cvtColor(img, COLOR_BGR2GRAY)
  ├─ [5] 检测人脸位置：detectMultiScale(gray, 1.2, 5)
  │     if 未检测到人脸:
  │         return {"recognized": false}
  ├─ [6] 提取人脸区域：face = gray[y:y+h, x:x+w]
  ├─ [7] LBPH 模型识别：idnum, conf = recognizer.predict(face)
  │     if conf < 100:
  │         return {"recognized": true, "userId": idnum, "userName": name}
  │     else:
  │         return {"recognized": false}
  └─ [8] 输出 JSON 到 stdout 并退出
        print(json.dumps(result))
        sys.exit(0)
  ↓
后端接收 stdout，解析 JSON：
  {"recognized": true, "userId": 6, "userName": "gpt"}
  ↓
后端根据识别结果：
  - 如果 recognized=true → 查询用户信息 → 验证任务 → 写入签到
  - 如果 recognized=false → 返回未识别
```

**关键参数说明**：

| 参数 | 代码位置 | 说明 | 默认值 | 作用 |
| --- | --- | --- | --- | --- |
| `scaleFactor` | 第 46 行 | 人脸检测缩放因子 | 1.2 | 控制检测尺度，越小检测越精确但越慢 |
| `minNeighbors` | 第 46 行 | 最小邻居数 | 5 | 过滤误检，越大误检越少但可能漏检 |
| `conf < 100` | 第 56 行 | 识别置信度阈值 | 100 | 判断识别是否成功，越小越严格 |

**识别结果示例**：

**识别成功**：
```json
{"recognized": true, "userId": 6, "userName": "gpt"}
```

**识别失败（未检测到人脸或置信度过高）**：
```json
{"recognized": false, "message": "unknown"}
```

**总结**：Python 识别脚本的核心是通过训练好的 LBPH 模型进行人脸识别，整个流程包括：加载模型 → 检测人脸 → 提取特征 → 模型识别 → 返回结果。识别过程与注册接口的校验逻辑相同，都是使用同一个模型和识别脚本。

**业务规则**：
- 只有学生可以进行人脸识别签到
- 识别成功返回用户信息和签到状态
- 识别失败返回未识别信息
- 如果提供了taskId，会验证任务的有效性
- 任务必须在有效时间范围内
- 学生必须属于任务的目标班级
- 签到记录失败不影响识别结果

## 签到管理流程

### 1. 自动签到流程（集成在人脸识别中）
```
人脸识别成功 → 获取用户ID → 验证签到任务 → 自动记录签到 → 返回签到状态
```

**详细步骤**：
1. **人脸识别**：学生通过人脸识别验证身份
2. **获取用户ID**：从识别结果中获取用户ID和班级信息
3. **任务验证**：如果提供了taskId，验证任务的有效性
4. **自动签到**：验证通过后系统自动插入签到记录到数据库
5. **状态返回**：在识别结果中包含签到状态

**业务规则**：
- 只有学生可以进行签到
- 签到时间自动记录为当前时间
- 默认签到状态为成功(1)
- 如果提供了taskId，会关联到具体的签到任务
- 任务必须在有效时间范围内
- 学生必须属于任务的目标班级
- 签到记录失败不影响识别结果
- 每次识别成功自动生成签到记录

### 2. 签到数据管理
```
签到记录自动创建 → 关联签到任务 → 数据库存储 → 统计分析
```

**数据特点**：
- 由系统自动创建，无需用户操作
- 与人脸识别结果绑定
- 可以关联到具体的签到任务
- 支持按任务进行数据分析和统计
- 记录完整的签到时间信息
- 支持签到率计算和学生详情查询

## 系统集成流程

### 1. 算法组集成流程
```
后端接收图片 → 调用算法组API → 传递图片路径 → 算法组处理 → 返回处理结果 → 后端处理结果
```

**集成要点**：
- **接口标准化**：统一的API调用格式
- **错误处理**：算法组服务异常处理
- **超时控制**：设置合理的请求超时时间
- **重试机制**：失败时的重试策略

### 2. 前后端交互流程（混合模式）

**RESTful API 交互**：
```
前端用户操作 → 发送HTTP请求 → 后端API处理 → 数据库操作 → 返回JSON响应 → 前端界面更新
```

**Socket.IO 实时交互**：
```
前端连接Socket → 身份验证 → 加入房间 → 监听事件 → 接收实时推送 → 自动更新界面
```

**交互特点**：
- **RESTful API**：标准化的接口设计，用于数据查询、提交操作
- **Socket.IO**：实时双向通信，用于任务推送、状态更新
- **混合模式**：Socket.IO 负责实时推送，REST API 负责数据操作和备用查询
- **JSON格式**：统一的数据交换格式
- **状态码**：HTTP状态码表示请求结果
- **错误处理**：统一的错误信息格式
- **自动降级**：Socket 连接断开时，自动使用 REST API 作为备用

## 数据流转流程

### 1. 用户数据流转
```
学生注册 → 选择班级 → 密码加密 → 数据库存储 → 登录验证 → 签发JWT（包含角色/班级） → 业务操作（携带Authorization） → 数据更新
```

### 2. 班级数据流转
```
系统预置班级 → 数据库存储 → 前端获取 → 学生注册选择 → 签到任务关联
```

### 3. 签到任务数据流转（含实时推送）
```
老师发布任务 → 数据库存储 → Socket.IO实时推送 → 学生实时接收 → 人脸识别签到 → 关联签到记录
                                          ↓
                                    学生查看任务（API备用）
```

### 4. 图片数据流转
```
学生上传 → 文件接收 → 本地存储 → 算法组调用 → 特征提取 → 结果返回 → 状态更新
```

### 5. 签到数据流转
```
人脸识别成功 → 验证签到任务 → 自动签到记录生成 → 关联任务ID → 数据库存储 → 统计分析
```

### 6. 统计数据流转
```
签到记录生成 → 按任务聚合 → 计算签到率 → 生成统计报告 → 老师查看
```

## 异常处理流程

### 1. 用户认证异常
```
认证失败 → 错误信息返回 → 前端提示 → 用户重新输入
```

### 2. 文件上传异常
```
文件过大 → 大小限制 → 错误提示 → 用户重新选择
文件格式错误 → 类型检查 → 错误提示 → 用户重新上传
```

### 3. 算法组调用异常
```
算法组服务不可用 → 超时处理 → 错误返回 → 用户重试
识别失败 → 结果处理 → 友好提示 → 用户重新识别
签到记录失败 → 错误日志 → 不影响识别结果 → 系统继续运行
```

### 4. 角色权限异常
```
学生访问老师功能 → 权限检查 → 403错误 → 友好提示
老师访问学生功能 → 权限检查 → 403错误 → 友好提示
未登录访问受保护接口 → 401错误 → 跳转登录页面
```

### 5. 签到任务异常
```
任务时间已过期 → 时间验证 → 错误提示 → 学生重新选择
学生不属于目标班级 → 班级验证 → 错误提示 → 学生确认班级
任务不存在 → 任务验证 → 错误提示 → 老师检查任务
老师跨班级发布任务 → 班级权限验证 → 错误提示 → 老师选择正确班级
```

### 6. 班级管理异常
```
班级不存在 → 班级验证 → 错误提示 → 学生重新选择
班级数据加载失败 → 数据库查询异常 → 错误提示 → 系统重试
```

## 完整业务流程总结

### 学生端流程
```
学生注册 → 选择班级 → 人脸注册 → 查看签到任务 → 人脸识别签到 → 查看签到状态
```

### 老师端流程
```
老师登录 → 发布签到任务 → 查看任务列表 → 查看签到统计 → 分析签到数据
```

### 系统管理流程
```
系统初始化 → 预置班级和老师数据 → 学生注册管理 → 签到任务管理 → 数据统计分析
```

这些业务流程构成了完整的人脸识别签到系统，支持角色管理、班级管理和签到任务管理，形成了完整的业务闭环。通过角色分离和功能集成，系统更加高效、安全和易用。
